----------------------------------------------------------------
THIS PROMPT WAS USED IN GEMINI 3
----------------------------------------------------------------

Gemini 3, What I need you to do is very specific. Extremely specific. The request is as if it can/cannot be completed unless you give me the full code in a single response.
To give you an idea of what we're making, it's an Encryption Tool. The encryption tool is a notepad. TOTAL NOTEPAD. When saved, it saves the file in an encrypted manner.
Other applications won't be able to open it. It can only be opened with this program. However, the encryption isn't pre-established. It is a custom-encryption that we're going to build.

Okay. After all the introduction, let me give you information regarding the application. After the notepad interface, what I need you to do is the following:
1) Generate 100 mathematical functions (one-to-one) with F(xyz) variables = equation. The equation should be different. The equation should also be extremely complex. No matter how complex the equation is, we can get the answer by putting number in x, y and z. The complexity is that it is extremely difficult for a person to come up with a solution even after they have the values to x, y and z by using a copy. They must use the calculator. The equation is that long and complex. I need you to use your searching mechanism or generating mechanism to create these functions, where each function is different to each other, 100 functions and "HARDCODE" them in the code. These functions do not change nor are they dynamic.

2) How does the encryption work?
	A) It first converts the entire character or string that the user has typed to ASCII value. It then records them in a list in the form of an item per each character. This list is going to be extremely lengthy as it increases per character typed by the user. This list is created inside the application and isn't stored anywhere. Just the application logic.

	B) It randomly shuffles through those 100 mathematical functions and creates an index to follow. Those indexes are also stored in a list to be able to loop through easily. This will shuffle the usual 0th term of 100 mathematical functions to 99th term, TO shuffled version of indexes. The initial index is same, you don't change that. But how to go through each index to pick the mathematical functions is different and stored in a different list. The list will contain the shuffled version of the index of the list that contains the mathematical functions. 

	C) Now, we use the shuffled functions and fill the variables with the ASCII value. We apply the function by filling x=first_ASCII_of_the_list, y=second, z=third and keep going until we reach the 100th function. Now, in order to use ONLY 100 functions whose indexes were scrambled, we need to make sure about a lot of things.
		I) First, if there are 300 ASCII Values, it means that 100 functions are perfectly capable of calculating the output and we can form the input if we do it in reverse.
		II) Second, if the total ASCII items cannot be used completely. Case: If there are 250 ASCII items but there are 100 functions with x,y,z variables. In this case, we need an extra 50 ASCII items. In this case, it automatically detects and fills the remaining with "LOREM" text or "JUNK" text that is constant and already defined in the application, and it only fills the real-user-text with 50 characters of the LOREM or JUNK text. This applies in cases where if there are 550 ASCII items, it means that the function can be completed once but it cannot be fully completed twice because 100 functions = 300 ASCII items and there are 550. We need an extra 50. Hence, for this 50, we need lorem, the same logic.

		III) If decryption ever occurs, it automatically detects the lorem or junk text and removes it from the decrypted file.

3) How does the decryption work?
	A) Since the encryption happened through all one-to-one function, getting an exact value for xyz is a guarantee. Hence, it works in that way but in order to know which function was used, we need to know the randomly shuffled indexes of those functions. In the moment of encryption, it actually returns the indexes as a secret key to the user to store somewhere. That indexing is auto-saved in the application and used for upcoming encryption. If the indexes are there, the application won't be generating the indexes again for the next time when the user encrypts some text and saves it. However, if the user wants, they can remove that index. Before removing that index, the app will ask the user to keep it in a backup.txt file. Once kept, the index will be removed and the next time, it will be re generated randomly again repeating this process. 
	B) When the decryption is happening, the user has the option to 
		I) EITHER, use the auto-saved indexes as key to decrypt the encrypted text file.
		II) OR, use the indexes that the user has saved somewhere to decrypt the encrypted text file.
	C) Once the application gathers all the required x,y,z values and stores them in a list, they will be converted back to characters. Remember, you might be confused about what to do with " " blank spaces, even their ASCII should be recorded.
	D) The app will then fill the notepad interface with the actual original text.

4) The twist in encryption. There is a tool window aside from the file window which allows the user to access the "Special Redundant Encryption" option. Using that will open a new window that gives the user access to enable this option. Enabling this option will give the user selection from 2X to 10X which will perform encryption on encryption for the 2X to 10X as the user has chosen. However, this will increase the length of the key (indexes of randomized function) that is provided to the user since the encryption will work multiple times creating multiple randomized indexes. Once this option is enabled then the redundancy is also recorded in the key that is given to the user as the last item in the list as "r=2" or "r=3" .... "r=10" depending on the option selected. Using this option, the decryption logic should also be changed, not in a logic manner but in a manner where the decryption logic checks for the 'r' value in the list. If it doesn't exist, it does as normal. If it exists, it looks at the times which can be 2,3,4 .... 10 and depending upon that, it calculates the total lists of indexes recorded within the total list and decrypts in that manner. 
	A) Example: if r=3, it will check the length of the key provided to the user which will contain something like [[indexes_of_first_encryption], [indexes_of_second_encryption], [indexes_of_third_encryption], r=3] and then it will perform decryption from the third encryption and reaches to the second and finally to the first. If r=3, there are 4 items in the list, among which 3 are the indexes of the functions used. It will go from item0 to item2 and perform decryption from item2 to item0 ultimately coming at the conclusion and displaying the original file content. 
Note: If this option was disabled but the user has provided the key which contains r=3 and the pattern matches, or, if this option was disabled but the auto-save has r=3 and the pattern matches, the app will automatically use this option despite it being disabled to avoid overheads.

5) Go All Out. Make the code as long as possible. It's yours.
